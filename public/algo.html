<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Algo Cheat Sheet v5</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      ::-webkit-scrollbar {
        width: 8px;
      }
      ::-webkit-scrollbar-track {
        background: #1f2937;
      }
      ::-webkit-scrollbar-thumb {
        background: #4b5563;
        border-radius: 4px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #6b7280;
      }

      .node {
        transition: all 0.3s ease;
      }
      .active-node {
        fill: #ef4444 !important;
        stroke: #fff !important;
      }
      .visited-node {
        fill: #3b82f6 !important;
      }
      .queue-node {
        stroke: #eab308 !important;
        stroke-width: 3px !important;
      }

      .strike-through {
        text-decoration: line-through;
        color: #6b7280;
      }
      .highlight-coeff {
        border: 2px solid #34d399;
        background: #064e3b;
      }
      .highlight-result {
        border: 2px solid #facc15;
        background: #713f12;
      }

      /* Permutation path highlight */
      .perm-path {
        stroke: #ef4444;
        stroke-width: 3px;
      }
      .perm-leaf {
        fill: #ef4444 !important;
      }
    </style>
  </head>
  <body
    class="bg-slate-900 text-slate-200 font-mono flex h-screen overflow-hidden"
  >
    <!-- Sidebar -->
    <aside
      class="w-64 bg-slate-950 border-r border-slate-800 flex-shrink-0 flex flex-col overflow-y-auto hidden md:flex"
    >
      <div class="p-6 border-b border-slate-800">
        <h1 class="text-xl font-bold text-white tracking-tighter">
          ALGO_REF_v5
        </h1>
        <p class="text-xs text-slate-500 mt-1">Exam Prep Edition</p>
      </div>
      <nav class="flex-1 p-4 space-y-1">
        <a
          href="#bfs-dfs"
          class="block px-3 py-2 rounded hover:bg-slate-800 text-sm hover:text-white transition"
          >BFS & DFS</a
        >
        <a
          href="#topological"
          class="block px-3 py-2 rounded hover:bg-slate-800 text-sm hover:text-white transition"
          >Topological Sort</a
        >
        <a
          href="#permutation"
          class="block px-3 py-2 rounded hover:bg-slate-800 text-sm hover:text-white transition"
          >Permutation Tree</a
        >
        <a
          href="#horner"
          class="block px-3 py-2 rounded hover:bg-slate-800 text-sm hover:text-white transition"
          >Horner's Rule</a
        >
        <a
          href="#russian"
          class="block px-3 py-2 rounded hover:bg-slate-800 text-sm hover:text-white transition"
          >Russian Multiplication</a
        >
        <a
          href="#counting"
          class="block px-3 py-2 rounded hover:bg-slate-800 text-sm hover:text-white transition"
          >Counting Sort</a
        >
        <a
          href="#horspool"
          class="block px-3 py-2 rounded hover:bg-slate-800 text-sm hover:text-white transition"
          >Horspool Match</a
        >
        <a
          href="#dijkstra"
          class="block px-3 py-2 rounded hover:bg-slate-800 text-sm hover:text-white transition"
          >Dijkstra</a
        >
        <a
          href="#floyd"
          class="block px-3 py-2 rounded hover:bg-slate-800 text-sm hover:text-white transition"
          >Floyd-Warshall</a
        >
        <a
          href="#knapsack"
          class="block px-3 py-2 rounded hover:bg-slate-800 text-sm hover:text-white transition"
          >Knapsack (DP)</a
        >
      </nav>
    </aside>

    <!-- Main Content -->
    <main class="flex-1 overflow-y-auto p-6 md:p-12 relative scroll-smooth">
      <!-- Mobile Header -->
      <div class="md:hidden mb-8 border-b border-slate-700 pb-4">
        <h1 class="text-2xl font-bold text-white">ALGO_REF_v5</h1>
      </div>

      <!-- Section: BFS & DFS -->
      <section id="bfs-dfs" class="mx-auto max-w-6xl mb-24">
        <div class="flex items-center justify-between mb-6">
          <h2 class="text-3xl font-bold text-white">BFS and DFS</h2>
          <div class="flex items-center gap-4">
            <button
              onclick="generateRandomTree()"
              class="bg-emerald-600 hover:bg-emerald-500 text-white px-3 py-1 rounded text-sm font-bold"
            >
              Randomize Tree
            </button>
            <a
              href="https://www.youtube.com/watch?v=pcKY4hjDrxk"
              target="_blank"
              class="text-blue-400 hover:text-blue-300 text-sm flex items-center gap-1"
              >Watch Youtube Video Explanation</a
            >
          </div>
        </div>

        <div class="grid xl:grid-cols-2 gap-8 mb-8">
          <!-- BFS COLUMN -->
          <div
            class="bg-slate-800 rounded-lg p-4 border border-slate-700 shadow-lg flex flex-col"
          >
            <div class="flex justify-between items-center mb-4">
              <h3 class="text-lg font-bold text-blue-400">BFS (Queue)</h3>
              <div class="flex gap-2">
                <button
                  onclick="stepBFS()"
                  class="bg-blue-600 hover:bg-blue-500 text-white py-1 px-3 rounded text-xs font-bold"
                >
                  Step
                </button>
                <button
                  onclick="initBFS()"
                  class="bg-slate-700 hover:bg-slate-600 text-white py-1 px-3 rounded text-xs"
                >
                  Reset
                </button>
              </div>
            </div>
            <div
              class="bg-slate-900 rounded border border-slate-700 mb-4 h-64 relative"
            >
              <svg
                id="bfs-svg"
                width="100%"
                height="100%"
                class="select-none"
                viewBox="0 0 400 250"
              ></svg>
            </div>
            <div
              class="bg-slate-900 p-2 rounded border border-slate-700 text-xs font-mono h-20 overflow-y-auto"
            >
              <div class="text-slate-500">QUEUE:</div>
              <div
                id="bfs-queue-display"
                class="text-yellow-400 font-bold mb-1"
              >
                []
              </div>
              <div id="bfs-log" class="text-slate-300">Ready.</div>
            </div>
            <div
              class="bg-slate-900 p-2 rounded border border-slate-700 text-xs font-mono mt-2"
            >
              <div class="text-slate-500">VISITED ORDER:</div>
              <div id="bfs-visited-display" class="text-green-400 font-bold">
                []
              </div>
            </div>

            <div
              class="mt-4 text-xs text-slate-400 bg-slate-900/50 p-3 rounded"
            >
              <strong class="text-blue-400 block mb-1">How to do:</strong>
              <ul class="list-disc list-inside space-y-1">
                <li>Start at node A, put in Queue.</li>
                <li>Take front node, visit children.</li>
                <li>Add unvisited children to Queue.</li>
                <li>Cross out/finish node. Repeat.</li>
              </ul>
            </div>
          </div>

          <!-- DFS COLUMN -->
          <div
            class="bg-slate-800 rounded-lg p-4 border border-slate-700 shadow-lg flex flex-col"
          >
            <div class="flex justify-between items-center mb-4">
              <h3 class="text-lg font-bold text-purple-400">DFS (Stack)</h3>
              <div class="flex gap-2">
                <button
                  onclick="stepDFS()"
                  class="bg-purple-600 hover:bg-purple-500 text-white py-1 px-3 rounded text-xs font-bold"
                >
                  Step
                </button>
                <button
                  onclick="initDFS()"
                  class="bg-slate-700 hover:bg-slate-600 text-white py-1 px-3 rounded text-xs"
                >
                  Reset
                </button>
              </div>
            </div>
            <div
              class="bg-slate-900 rounded border border-slate-700 mb-4 h-64 relative"
            >
              <svg
                id="dfs-svg"
                width="100%"
                height="100%"
                class="select-none"
                viewBox="0 0 400 250"
              ></svg>
            </div>
            <div
              class="bg-slate-900 p-2 rounded border border-slate-700 text-xs font-mono h-20 overflow-y-auto"
            >
              <div class="text-slate-500">STACK (Top is right):</div>
              <div id="dfs-stack-display" class="text-pink-400 font-bold mb-1">
                []
              </div>
              <div id="dfs-log" class="text-slate-300">Ready.</div>
            </div>
            <div
              class="bg-slate-900 p-2 rounded border border-slate-700 text-xs font-mono mt-2"
            >
              <div class="text-slate-500">VISITED ORDER:</div>
              <div id="dfs-visited-display" class="text-green-400 font-bold">
                []
              </div>
            </div>

            <div
              class="mt-4 text-xs text-slate-400 bg-slate-900/50 p-3 rounded"
            >
              <strong class="text-purple-400 block mb-1">How to do:</strong>
              <ul class="list-disc list-inside space-y-1">
                <li>Push start to Stack.</li>
                <li>Pop top, visit ONE child. Push child.</li>
                <li>Dive deep until stuck (dead end).</li>
                <li>Backtrack (pop) until new path found.</li>
              </ul>
            </div>
          </div>
        </div>
      </section>

      <!-- Section: Topological Sort -->
      <section
        id="topological"
        class="mx-auto max-w-5xl mb-24 border-t border-slate-800 pt-12"
      >
        <div class="flex items-center justify-between mb-6">
          <h2 class="text-2xl font-bold text-white">Topological Sort</h2>
          <div class="flex items-center gap-4">
            <button
              onclick="generateRandomDAG()"
              class="bg-emerald-600 hover:bg-emerald-500 text-white px-3 py-1 rounded text-sm font-bold"
            >
              Randomize Graph
            </button>
            <a
              href="https://www.youtube.com/watch?v=7J3GadLzydI"
              target="_blank"
              class="text-blue-400 hover:text-blue-300 text-sm"
              >Watch Youtube Video Explanation</a
            >
          </div>
        </div>

        <div class="bg-slate-800 p-6 rounded-lg border border-slate-700">
          <div class="flex flex-col md:flex-row gap-6">
            <div
              class="flex-1 relative bg-slate-900 rounded border border-slate-700"
            >
              <svg
                id="topo-svg"
                width="100%"
                height="250"
                class="select-none"
                viewBox="0 0 400 250"
              ></svg>
            </div>
            <div class="w-full md:w-64 space-y-4">
              <button
                onclick="topoNextStep()"
                class="w-full bg-emerald-600 hover:bg-emerald-500 text-white py-2 rounded font-bold"
              >
                Next Step
              </button>
              <button
                onclick="initTopo()"
                class="w-full bg-slate-700 text-slate-300 py-2 rounded"
              >
                Reset
              </button>

              <div class="bg-slate-900 p-3 rounded border border-slate-700">
                <h4 class="text-xs text-slate-500 uppercase mb-2">
                  Dead-End Stack
                </h4>
                <div
                  id="topo-stack"
                  class="flex flex-wrap gap-2 text-emerald-400 font-bold min-h-[30px] text-xs"
                ></div>
              </div>

              <!-- Final Result Container -->
              <div
                class="bg-black p-3 rounded border border-emerald-500 hidden"
                id="topo-result-box"
              >
                <h4 class="text-xs text-emerald-500 uppercase mb-1">
                  Final Result (Stack Reversed)
                </h4>
                <div
                  id="topo-final-order"
                  class="text-white font-bold text-sm tracking-widest"
                ></div>
              </div>

              <div id="topo-log" class="text-xs text-yellow-400 font-mono h-10">
                Ready.
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- Section: Permutation (Johnson-Trotter) -->
      <section
        id="permutation"
        class="mx-auto max-w-5xl mb-24 border-t border-slate-800 pt-12"
      >
        <div class="flex items-center justify-between mb-6">
          <h2 class="text-2xl font-bold text-white">
            Permutation (Johnson-Trotter)
          </h2>
          <a
            href="https://www.youtube.com/watch?v=xsFKorZ95Yw"
            target="_blank"
            class="text-blue-400 hover:text-blue-300 text-sm"
            >Watch Youtube Video Explanation</a
          >
        </div>
        <p class="text-slate-400 mb-4 text-sm">
          Generates permutations by swapping adjacent elements. An element is
          "mobile" if it points to a smaller adjacent element.
        </p>

        <div class="bg-slate-800 p-6 rounded border border-slate-700">
          <div class="flex flex-col md:flex-row gap-8 mb-6">
            <div class="w-full md:w-1/3 space-y-4">
              <div>
                <label class="block text-xs text-slate-500 mb-1"
                  >Number of Elements (N)</label
                >
                <div class="flex gap-2">
                  <input
                    type="number"
                    id="jtInput"
                    value="4"
                    min="2"
                    max="5"
                    class="bg-slate-900 border border-slate-600 text-white px-3 py-2 rounded font-mono w-20"
                  />
                  <button
                    onclick="initJT()"
                    class="bg-slate-700 hover:bg-slate-600 text-white px-4 py-2 rounded font-bold text-sm flex-1"
                  >
                    Reset
                  </button>
                </div>
              </div>
              <div class="flex gap-2">
                <button
                  onclick="stepJT()"
                  class="flex-1 bg-blue-600 hover:bg-blue-500 text-white px-4 py-3 rounded font-bold text-sm shadow-lg shadow-blue-900/20"
                >
                  Next Step
                </button>
                <button
                  onclick="runAllJT()"
                  class="flex-1 bg-purple-600 hover:bg-purple-500 text-white px-4 py-3 rounded font-bold text-sm shadow-lg shadow-purple-900/20"
                >
                  Generate All
                </button>
              </div>
              <div
                class="bg-slate-900 p-3 rounded border border-slate-700 min-h-[80px]"
              >
                <div class="text-xs text-slate-500 uppercase mb-1">Status</div>
                <div
                  id="jt-status"
                  class="text-yellow-400 text-sm font-mono leading-tight"
                >
                  Ready.
                </div>
              </div>
            </div>

            <div
              class="flex-1 bg-slate-900 rounded border border-slate-700 p-8 flex flex-col items-center justify-center min-h-[200px]"
            >
              <div id="jt-visual" class="flex gap-4 mb-8">
                <!-- Blocks go here -->
              </div>
              <div class="text-slate-500 text-xs">Current Permutation</div>
            </div>
          </div>

          <div class="bg-slate-900 rounded border border-slate-700 p-4">
            <h4 class="text-xs text-slate-500 uppercase mb-2">
              History (<span id="jt-count">0</span>)
            </h4>
            <div
              id="jt-history"
              class="flex flex-col gap-1 font-mono text-sm text-emerald-400 max-h-64 overflow-y-auto p-2"
            ></div>
          </div>
        </div>
      </section>

      <!-- Section: Horner's Rule -->
      <section
        id="horner"
        class="mx-auto max-w-5xl mb-24 border-t border-slate-800 pt-12"
      >
        <div class="flex items-center justify-between mb-6">
          <h2 class="text-2xl font-bold text-white">Horner's Rule</h2>
          <div class="flex items-center gap-4">
            <button
              onclick="randomizeHorner()"
              class="bg-emerald-600 hover:bg-emerald-500 text-white px-3 py-1 rounded text-sm font-bold"
            >
              Randomize Input
            </button>
            <a
              href="https://www.youtube.com/watch?v=Z393AcN_Gz0"
              target="_blank"
              class="text-blue-400 hover:text-blue-300 text-sm"
              >Watch Youtube Video Explanation</a
            >
          </div>
        </div>

        <div
          class="mb-6 bg-slate-800 p-4 rounded text-sm text-slate-300 border border-slate-700"
        >
          <h4 class="font-bold text-white mb-2">Steps:</h4>
          <ol class="list-decimal list-inside space-y-1">
            <li>Pull down first coefficient</li>
            <li>Multiply by x → Add to next value</li>
            <li>Repeat. The last number is your result.</li>
          </ol>
        </div>

        <div class="bg-slate-800 p-6 rounded border border-slate-700">
          <div class="grid md:grid-cols-2 gap-4 mb-6">
            <div>
              <label class="block text-xs text-slate-500 mb-1"
                >Coefficients</label
              >
              <input
                type="text"
                id="hornerCoeffs"
                value="-3 0 2 -5 9 29"
                class="w-full bg-slate-900 border border-slate-600 px-3 py-2 rounded text-white font-mono"
                onkeyup="updatePolynomial()"
              />
            </div>
            <div>
              <label class="block text-xs text-slate-500 mb-1">X Value</label>
              <div class="flex gap-2">
                <input
                  type="number"
                  id="hornerX"
                  value="5"
                  class="w-24 bg-slate-900 border border-slate-600 px-3 py-2 rounded text-white font-mono"
                />
                <button
                  onclick="initHorner()"
                  class="bg-slate-700 hover:bg-slate-600 text-white px-4 rounded text-xs font-bold"
                >
                  Reset
                </button>
              </div>
            </div>
          </div>

          <div
            id="poly-display"
            class="mb-4 text-emerald-400 font-mono text-sm border-b border-slate-700 pb-2"
          >
            <!-- Polynomial formula will appear here -->
          </div>

          <div class="overflow-x-auto mb-4">
            <div
              id="horner-container"
              class="min-w-[600px] flex flex-col gap-2 font-mono text-lg"
            ></div>
          </div>

          <div
            class="flex items-center justify-between bg-slate-900 p-3 rounded border border-slate-700"
          >
            <div id="horner-explanation" class="text-yellow-400 text-sm">
              Click Start to begin.
            </div>
            <button
              onclick="hornerStep()"
              class="bg-emerald-600 hover:bg-emerald-500 text-white px-6 py-2 rounded font-bold"
            >
              Next Step
            </button>
          </div>
        </div>
      </section>

      <!-- Section: Russian Multiplication -->
      <section
        id="russian"
        class="mx-auto max-w-5xl mb-24 border-t border-slate-800 pt-12"
      >
        <div class="flex items-center justify-between mb-6">
          <h2 class="text-2xl font-bold text-white">Russian Multiplication</h2>
          <div class="flex items-center gap-4">
            <button
              onclick="randomizeRussian()"
              class="bg-emerald-600 hover:bg-emerald-500 text-white px-3 py-1 rounded text-sm font-bold"
            >
              Randomize Input
            </button>
            <a
              href="https://www.youtube.com/watch?v=xrUCL7tGKaI"
              target="_blank"
              class="text-blue-400 hover:text-blue-300 text-sm"
              >Watch Youtube Video Explanation</a
            >
          </div>
        </div>

        <div class="flex flex-col md:flex-row gap-8">
          <div class="w-full md:w-64 space-y-4">
            <p class="text-sm text-slate-400">
              Halve left side, double right side. Take only rows where left side
              is ODD.
            </p>
            <div class="bg-slate-800 p-4 rounded border border-slate-700">
              <div class="flex gap-2 mb-2">
                <input
                  type="number"
                  id="russianA"
                  value="12"
                  class="w-1/2 bg-slate-900 border border-slate-600 px-2 py-1 rounded text-white"
                />
                <input
                  type="number"
                  id="russianB"
                  value="23"
                  class="w-1/2 bg-slate-900 border border-slate-600 px-2 py-1 rounded text-white"
                />
              </div>
              <button
                onclick="calcRussian()"
                class="w-full bg-blue-600 hover:bg-blue-500 text-white py-2 rounded font-bold"
              >
                Visualize
              </button>
            </div>
          </div>
          <div
            id="russianOutput"
            class="flex-1 bg-slate-900 border border-slate-700 p-6 rounded font-mono"
          ></div>
        </div>
      </section>

      <!-- Section: Counting Sort -->
      <section
        id="counting"
        class="mx-auto max-w-5xl mb-24 border-t border-slate-800 pt-12"
      >
        <div class="flex items-center justify-between mb-6">
          <h2 class="text-2xl font-bold text-white">Counting Sort</h2>
          <div class="flex items-center gap-4">
            <button
              onclick="randomizeCounting()"
              class="bg-emerald-600 hover:bg-emerald-500 text-white px-3 py-1 rounded text-sm font-bold"
            >
              Randomize Input
            </button>
            <a
              href="https://www.youtube.com/watch?v=OKd534EWcdk"
              target="_blank"
              class="text-blue-400 hover:text-blue-300 text-sm"
              >Watch Youtube Video Explanation</a
            >
          </div>
        </div>

        <div class="grid md:grid-cols-2 gap-8 mb-6 text-sm text-slate-300">
          <div class="bg-slate-800 p-4 rounded border border-slate-700">
            <h4 class="font-bold text-white mb-2">Step 1: Count Freq</h4>
            <p>Count how many times each number appears.</p>
            <div class="bg-slate-900 p-2 mt-2 font-mono text-xs">
              0=1, 1=3, 2=0, 3=2...
            </div>
          </div>
          <div class="bg-slate-800 p-4 rounded border border-slate-700">
            <h4 class="font-bold text-white mb-2">Step 2: Cumulative</h4>
            <p>
              Add counts cumulatively:
              <code class="bg-slate-900 px-1">count[i] + count[i-1]</code>
            </p>
            <h4 class="font-bold text-white mt-2 mb-1">Step 3: Shift Right</h4>
            <p>
              Shift the cumulative table right by 1 to get STARTING indices.
            </p>
          </div>
        </div>

        <div class="bg-slate-800 p-6 rounded border border-slate-700">
          <div class="flex gap-4 mb-6">
            <input
              type="text"
              id="countInput"
              value="1, 0, 3, 1, 3, 1"
              class="flex-1 bg-slate-900 border border-slate-600 text-white px-3 py-2 rounded font-mono"
            />
            <button
              onclick="calcCounting()"
              class="bg-blue-600 px-6 rounded text-white font-bold"
            >
              Sort
            </button>
          </div>
          <div id="countingSteps" class="space-y-8"></div>
        </div>
      </section>

      <!-- Section: Horspool -->
      <section
        id="horspool"
        class="mx-auto max-w-5xl mb-24 border-t border-slate-800 pt-12"
      >
        <div class="flex items-center justify-between mb-6">
          <h2 class="text-2xl font-bold text-white">Horspool Algorithm</h2>
          <a
            href="https://www.youtube.com/watch?v=fmXx7OgQEOM&pp=ygUaaG9yc3Bvb2wgYWxnb3JpdGhtIGV4YW1wbGU%3D"
            target="_blank"
            class="text-blue-400 hover:text-blue-300 text-sm"
            >Watch Youtube Video Explanation</a
          >
        </div>

        <div class="grid md:grid-cols-2 gap-8 mb-6">
          <div class="space-y-4 text-sm text-slate-300">
            <h3 class="font-bold text-emerald-400">
              Step 1: Build Shift Table
            </h3>
            <p>
              Formula:
              <code class="bg-slate-800 px-1 text-white"
                >length - index - 1</code
              >
            </p>
            <p>
              Use the right-most occurrence of a char (except the very last
              one). If char not in pattern, shift = length.
            </p>
          </div>
          <div class="space-y-4 text-sm text-slate-300">
            <h3 class="font-bold text-emerald-400">Step 2: Matching</h3>
            <ul class="list-disc list-inside">
              <li>Align Pattern with Text</li>
              <li>Check <strong>last character</strong> first</li>
              <li>Mismatch? Look at char in TEXT. Shift by table value.</li>
              <li>Repeat until match or end.</li>
            </ul>
          </div>
        </div>

        <div class="grid md:grid-cols-2 gap-8">
          <div class="space-y-4">
            <div class="bg-slate-800 p-4 rounded border border-slate-700">
              <label class="block text-xs text-slate-500 mb-1">Text</label>
              <input
                type="text"
                id="horspoolText"
                value="JIM_SAW_ME_IN_BARBERSHOP"
                class="w-full bg-slate-900 border border-slate-600 px-2 py-1 rounded text-white font-mono text-sm mb-2 uppercase"
              />
              <label class="block text-xs text-slate-500 mb-1">Pattern</label>
              <input
                type="text"
                id="horspoolPattern"
                value="BARBER"
                class="w-full bg-slate-900 border border-slate-600 px-2 py-1 rounded text-white font-mono text-sm uppercase"
              />

              <div class="flex gap-2 mt-4">
                <button
                  onclick="initHorspool()"
                  class="bg-slate-600 px-3 py-1 rounded text-white text-sm"
                >
                  Reset
                </button>
                <button
                  onclick="horspoolStep()"
                  class="bg-purple-600 hover:bg-purple-500 px-4 py-1 rounded text-white font-bold text-sm flex-1"
                >
                  Next Step
                </button>
              </div>
            </div>
            <div
              id="horspool-table-display"
              class="bg-slate-800 p-4 rounded border border-slate-700"
            >
              <div class="text-xs text-slate-500 mb-2">SHIFT TABLE</div>
              <div id="h-table-content" class="flex flex-wrap gap-2"></div>
            </div>
          </div>

          <div
            class="bg-slate-900 border border-slate-700 p-4 rounded overflow-x-auto relative min-h-[200px] flex items-center"
          >
            <div
              id="horspool-vis-container"
              class="font-mono text-xl whitespace-nowrap"
            ></div>
          </div>
        </div>
        <div
          id="horspool-log"
          class="mt-4 text-center text-yellow-400 font-mono text-sm h-6"
        ></div>
      </section>

      <!-- Section: Dijkstra -->
      <section
        id="dijkstra"
        class="mx-auto max-w-5xl mb-32 border-t border-slate-800 pt-12"
      >
        <div class="flex items-center justify-between mb-6">
          <h2 class="text-2xl font-bold text-white">Dijkstra</h2>
          <div class="flex items-center gap-4">
            <button
              onclick="generateRandomWeightedGraph()"
              class="bg-emerald-600 hover:bg-emerald-500 text-white px-3 py-1 rounded text-sm font-bold"
            >
              Randomize Graph
            </button>
            <a
              href="https://www.youtube.com/watch?v=XB4MIexjvY0"
              target="_blank"
              class="text-blue-400 hover:text-blue-300 text-sm"
              >Watch Youtube Video Explanation</a
            >
          </div>
        </div>

        <div class="bg-slate-800 p-6 rounded border border-slate-700 mb-6">
          <h3 class="font-bold text-white mb-2">How it works:</h3>
          <ul class="list-disc list-inside text-sm text-slate-300 space-y-2">
            <li>
              Pick <strong>start node</strong> (A), set distance to 0, all
              others to Infinity (∞).
            </li>
            <li>Look at neighbors of current node.</li>
            <li>
              Calculate new distance:
              <code class="bg-slate-900 px-1 text-yellow-400"
                >current_dist + edge_weight</code
              >.
            </li>
            <li>
              If new distance is <strong>smaller</strong> than old distance,
              update it.
            </li>
            <li>Mark current node as visited.</li>
            <li>
              Pick the <strong>smallest unvisited node</strong> as the next
              current node.
            </li>
            <li>Repeat until all nodes are visited.</li>
          </ul>
        </div>

        <div class="bg-slate-800 p-6 rounded border border-slate-700">
          <div class="flex flex-col lg:flex-row gap-8">
            <div class="flex-1">
              <svg
                id="dijkstra-svg"
                width="100%"
                height="300"
                class="bg-slate-900 rounded border border-slate-700 select-none"
              ></svg>
            </div>
            <div class="flex-1 flex flex-col">
              <div class="flex gap-2 mb-4">
                <button
                  onclick="dijkstraNext()"
                  class="bg-blue-600 hover:bg-blue-500 text-white flex-1 py-2 rounded font-bold"
                >
                  Next Step
                </button>
                <button
                  onclick="initDijkstra()"
                  class="bg-slate-700 text-white px-4 rounded"
                >
                  Reset
                </button>
              </div>
              <div
                class="bg-white text-slate-900 rounded overflow-hidden shadow-lg flex-1 overflow-x-auto max-h-[300px]"
              >
                <table
                  id="dijkstra-table"
                  class="w-full text-sm font-mono text-center border-collapse"
                >
                  <thead
                    class="bg-slate-200 border-b border-slate-300 sticky top-0 shadow"
                  >
                    <tr>
                      <!-- Injected by JS -->
                    </tr>
                  </thead>
                  <tbody id="dijkstra-table-body"></tbody>
                </table>
              </div>
              <div
                id="dijkstra-log"
                class="mt-2 text-xs text-yellow-400 font-mono h-5"
              ></div>
            </div>
          </div>
        </div>
      </section>

      <!-- Section: Floyd-Warshall -->
      <section
        id="floyd"
        class="mx-auto max-w-5xl mb-32 border-t border-slate-800 pt-12"
      >
        <div class="flex items-center justify-between mb-6">
          <h2 class="text-2xl font-bold text-white">
            Floyd-Warshall (All-Pairs Shortest Path)
          </h2>
          <div class="flex items-center gap-4">
            <button
              onclick="generateRandomFloyd()"
              class="bg-emerald-600 hover:bg-emerald-500 text-white px-3 py-1 rounded text-sm font-bold"
            >
              Randomize Graph
            </button>
            <a
              href="https://www.youtube.com/watch?v=4OQeCuLYj-4"
              target="_blank"
              class="text-blue-400 hover:text-blue-300 text-sm"
              >Watch Youtube Video Explanation</a
            >
          </div>
        </div>

        <div class="bg-slate-800 p-6 rounded border border-slate-700 mb-6">
          <h3 class="font-bold text-white mb-2">How it works:</h3>
          <ul class="list-disc list-inside text-sm text-slate-300 space-y-2">
            <li>
              Initialize distance matrix D with edge weights (∞ if no edge, 0
              diagonal).
            </li>
            <li>
              Iterate through every node <strong>k</strong> (as an intermediate
              node).
            </li>
            <li>For every pair (i, j), check if going through k is shorter:</li>
            <li>
              <code class="bg-slate-900 px-1 text-yellow-400"
                >D[i][j] = min(D[i][j], D[i][k] + D[k][j])</code
              >
            </li>
          </ul>
          <div class="mt-4">
            <p class="text-xs text-slate-500 mb-2">
              Professor's Whiteboard Note:
            </p>
            <img
              src="flo.png"
              alt="Floyd-Warshall Whiteboard Explanation"
              class="rounded border border-slate-600 max-w-sm h-auto"
            />
          </div>
        </div>

        <div class="bg-slate-800 p-6 rounded border border-slate-700">
          <div class="flex flex-col lg:flex-row gap-8">
            <div class="flex-1">
              <svg
                id="floyd-svg"
                width="100%"
                height="300"
                class="bg-slate-900 rounded border border-slate-700 select-none"
              ></svg>
            </div>
            <div class="flex-1 flex flex-col">
              <div class="flex gap-2 mb-4">
                <button
                  onclick="floydNext()"
                  class="bg-blue-600 hover:bg-blue-500 text-white flex-1 py-2 rounded font-bold"
                >
                  Next Step
                </button>
                <button
                  onclick="runAllFloyd()"
                  class="bg-purple-600 hover:bg-purple-500 text-white px-4 rounded font-bold"
                >
                  Run All
                </button>
                <button
                  onclick="initFloyd()"
                  class="bg-slate-700 text-white px-4 rounded"
                >
                  Reset
                </button>
              </div>

              <div
                class="bg-slate-900 p-4 rounded border border-slate-700 mb-4"
              >
                <div class="flex justify-between text-xs text-slate-500 mb-2">
                  <span>Distance Matrix (D)</span>
                  <span id="floyd-step-info" class="text-yellow-400"
                    >k=-1 (Init)</span
                  >
                </div>
                <div
                  id="floyd-matrix"
                  class="grid gap-1 font-mono text-sm text-center"
                >
                  <!-- Matrix injected here -->
                </div>
              </div>

              <div
                id="floyd-log"
                class="mt-2 text-xs text-yellow-400 font-mono h-10 overflow-y-auto"
              >
                Ready.
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- Section: Knapsack -->
      <section
        id="knapsack"
        class="mx-auto max-w-5xl mb-32 border-t border-slate-800 pt-12"
      >
        <div class="flex items-center justify-between mb-6">
          <h2 class="text-2xl font-bold text-white">Knapsack Problem (DP)</h2>
          <div class="flex items-center gap-4">
            <button
              onclick="generateRandomKnapsack()"
              class="bg-emerald-600 hover:bg-emerald-500 text-white px-3 py-1 rounded text-sm font-bold"
            >
              Randomize Items
            </button>
            <a
              href="https://www.youtube.com/watch?v=nLmhmB6NzcM"
              target="_blank"
              class="text-blue-400 hover:text-blue-300 text-sm"
              >Watch Youtube Video Explanation</a
            >
          </div>
        </div>

        <div class="bg-slate-800 p-6 rounded border border-slate-700 mb-6">
          <h3 class="font-bold text-white mb-2">How it works:</h3>
          <ul class="list-disc list-inside text-sm text-slate-300 space-y-2">
            <li>
              Create a table where rows are items and columns are capacities (0
              to Max Capacity).
            </li>
            <li>For each cell <code>dp[i][w]</code>:</li>
            <li>
              If item weight > w: <code>dp[i][w] = dp[i-1][w]</code> (Skip item)
            </li>
            <li>
              Else:
              <code>max(dp[i-1][w], value[i] + dp[i-1][w - weight[i]])</code>
              (Take or Skip)
            </li>
            <li>
              After filling, backtrack from bottom-right to find selected items.
            </li>
          </ul>
        </div>

        <div class="bg-slate-800 p-6 rounded border border-slate-700">
          <div class="flex flex-col gap-6">
            <!-- Controls -->
            <div class="flex flex-wrap gap-4 items-end">
              <div>
                <label class="block text-xs text-slate-500 mb-1"
                  >Capacity</label
                >
                <input
                  type="number"
                  id="ksCapacity"
                  value="5"
                  min="1"
                  max="10"
                  class="bg-slate-900 border border-slate-600 text-white px-3 py-2 rounded font-mono w-20"
                  onchange="initKnapsack()"
                />
              </div>
              <div class="flex-1">
                <label class="block text-xs text-slate-500 mb-1"
                  >Items (Weight, Value)</label
                >
                <div
                  id="ks-items-display"
                  class="flex gap-2 overflow-x-auto pb-2"
                >
                  <!-- Items injected here -->
                </div>
              </div>
            </div>

            <div class="flex gap-2">
              <button
                onclick="knapsackStep()"
                class="bg-blue-600 hover:bg-blue-500 text-white px-6 py-2 rounded font-bold"
              >
                Next Step
              </button>
              <button
                onclick="runAllKnapsack()"
                class="bg-purple-600 hover:bg-purple-500 text-white px-4 py-2 rounded font-bold"
              >
                Run All
              </button>
              <button
                onclick="initKnapsack()"
                class="bg-slate-700 text-white px-4 py-2 rounded"
              >
                Reset
              </button>
            </div>

            <!-- Table -->
            <div
              class="overflow-x-auto bg-slate-900 rounded border border-slate-700 p-4"
            >
              <div
                id="ks-table"
                class="grid gap-1 font-mono text-sm text-center"
              >
                <!-- Table injected here -->
              </div>
            </div>

            <div
              class="bg-slate-900 p-3 rounded border border-slate-700 min-h-[60px]"
            >
              <div class="text-xs text-slate-500 uppercase mb-1">Log</div>
              <div id="ks-log" class="text-yellow-400 text-sm font-mono">
                Ready.
              </div>
            </div>

            <div
              id="ks-result"
              class="hidden bg-emerald-900/30 border border-emerald-500 p-4 rounded"
            >
              <h4 class="text-emerald-400 font-bold mb-2">Selected Items:</h4>
              <div id="ks-selected-items" class="flex gap-2"></div>
            </div>
          </div>
        </div>
      </section>

      <footer class="text-center text-slate-600 text-xs pb-12">
        Good luck on the exam.
      </footer>
    </main>

    <script>
      // === BFS/DFS GRAPH DATA ===
      let nodesData = [
        { id: "A", x: 200, y: 30, children: ["B", "C"] },
        { id: "B", x: 120, y: 100, children: ["D", "E"] },
        { id: "C", x: 280, y: 100, children: ["F"] },
        { id: "D", x: 60, y: 180, children: [] },
        { id: "E", x: 160, y: 180, children: [] },
        { id: "F", x: 320, y: 180, children: [] },
      ];

      function generateRandomTree() {
        const nodeIds = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J"];
        const numNodes = Math.floor(Math.random() * 5) + 6; // 6 to 10 nodes
        const activeNodes = nodeIds.slice(0, numNodes);

        // Simple tree generation:
        // 1. Start with A
        // 2. For each subsequent node, pick a random parent from already added nodes
        // 3. Ensure max children per node is limited (e.g., 3)

        let tree = activeNodes.map((id) => ({ id, children: [], x: 0, y: 0 }));
        let added = [tree[0]]; // Start with A

        for (let i = 1; i < tree.length; i++) {
          const node = tree[i];
          // Find potential parents (nodes in 'added' with < 3 children)
          const potentialParents = added.filter((n) => n.children.length < 3);
          if (potentialParents.length === 0) break; // Should not happen with these limits

          const parent =
            potentialParents[
              Math.floor(Math.random() * potentialParents.length)
            ];
          parent.children.push(node.id);
          added.push(node);
        }

        // Layout (Improved Layered to avoid crossing)
        // Assign depths
        let depths = { A: 0 };
        let parents = { A: null };
        let maxDepth = 0;

        // BFS to assign depths and track parents
        let q = ["A"];
        while (q.length > 0) {
          const currId = q.shift();
          const currNode = tree.find((n) => n.id === currId);
          const d = depths[currId];
          maxDepth = Math.max(maxDepth, d);

          currNode.children.forEach((childId) => {
            depths[childId] = d + 1;
            parents[childId] = currNode;
            q.push(childId);
          });
        }

        // Assign X, Y based on depth and position in layer
        const width = 400;
        const height = 250;
        const layerHeight = height / (maxDepth + 2);

        // Group by depth
        let nodesByDepth = {};
        tree.forEach((n) => {
          const d = depths[n.id];
          if (!nodesByDepth[d]) nodesByDepth[d] = [];
          nodesByDepth[d].push(n);
        });

        // Process layers from top to bottom
        Object.keys(nodesByDepth)
          .sort((a, b) => a - b)
          .forEach((d) => {
            const depth = parseInt(d);
            let nodesInLayer = nodesByDepth[depth];

            if (depth > 0) {
              // Sort nodes based on parent's X position to minimize crossing
              nodesInLayer.sort((a, b) => {
                const parA = parents[a.id];
                const parB = parents[b.id];
                if (parA === parB) return 0; // Same parent, keep order
                return parA.x - parB.x;
              });
            }

            const layerWidth = width / (nodesInLayer.length + 1);
            nodesInLayer.forEach((n, idx) => {
              n.y = 30 + depth * layerHeight;
              n.x = (idx + 1) * layerWidth;
            });
          });

        nodesData = tree;
        initBFS();
        initDFS();
      }

      let bfsState = {
        queue: [],
        visited: new Set(),
        current: null,
        finished: false,
      };
      let dfsState = {
        stack: [],
        visited: new Set(),
        current: null,
        finished: false,
      };

      function drawGraph(svgId, nodes) {
        const svg = document.getElementById(svgId);
        let html = "";
        // Edges
        nodes.forEach((n) => {
          n.children.forEach((childId) => {
            const child = nodes.find((x) => x.id === childId);
            if (child)
              html += `<line x1="${n.x}" y1="${n.y}" x2="${child.x}" y2="${child.y}" stroke="#475569" stroke-width="2" />`;
          });
        });
        // Nodes
        nodes.forEach((n) => {
          html += `
                    <g class="node-group" id="${svgId}-node-${n.id}">
                        <circle cx="${n.x}" cy="${n.y}" r="15" fill="#1e293b" stroke="#94a3b8" stroke-width="2" class="node" />
                        <text x="${n.x}" y="${n.y}" dy="5" text-anchor="middle" fill="white" font-weight="bold" font-size="12">${n.id}</text>
                    </g>
                `;
        });
        svg.innerHTML = html;
      }

      function highlightNodeGraph(svgId, id, type) {
        const el = document.querySelector(`#${svgId}-node-${id} circle`);
        if (!el) return;
        if (type === "reset") {
          el.setAttribute("class", "node");
          return;
        }
        if (type === "active") el.setAttribute("class", "node active-node");
        if (type === "visited") el.setAttribute("class", "node visited-node");
        if (type === "queue") el.setAttribute("class", "node queue-node");
      }

      // BFS LOGIC
      function initBFS() {
        bfsState = {
          queue: ["A"],
          visited: new Set(["A"]),
          visitedOrder: [],
          current: null,
          finished: false,
        };
        drawGraph("bfs-svg", nodesData);
        document.getElementById("bfs-log").innerText = "Ready. Start at A.";
        document.getElementById("bfs-queue-display").innerText = "[A]";
        document.getElementById("bfs-visited-display").innerText = "[]";
        highlightNodeGraph("bfs-svg", "A", "queue");
      }

      function stepBFS() {
        if (bfsState.finished) return;
        if (bfsState.queue.length === 0) {
          bfsState.finished = true;
          document.getElementById("bfs-log").innerText = "Queue empty. Done.";
          return;
        }
        const curr = bfsState.queue.shift();
        bfsState.current = curr;
        bfsState.visitedOrder.push(curr);
        document.getElementById(
          "bfs-visited-display"
        ).innerText = `[${bfsState.visitedOrder.join(", ")}]`;
        highlightNodeGraph("bfs-svg", curr, "active");
        document.getElementById(
          "bfs-log"
        ).innerText = `Visiting ${curr}. Adding unvisited children...`;
        document.getElementById(
          "bfs-queue-display"
        ).innerText = `[${bfsState.queue.join(", ")}]`;

        const nodeObj = nodesData.find((n) => n.id === curr);
        let added = [];
        nodeObj.children.forEach((child) => {
          if (!bfsState.visited.has(child)) {
            bfsState.visited.add(child);
            bfsState.queue.push(child);
            added.push(child);
            highlightNodeGraph("bfs-svg", child, "queue");
          }
        });
        document.getElementById(
          "bfs-queue-display"
        ).innerText = `[${bfsState.queue.join(", ")}]`;
        if (added.length > 0)
          document.getElementById("bfs-log").innerText += ` Added ${added.join(
            ", "
          )}.`;
        else
          document.getElementById("bfs-log").innerText += ` No new children.`;

        nodesData.forEach((n) => {
          if (
            bfsState.visited.has(n.id) &&
            n.id !== curr &&
            !bfsState.queue.includes(n.id)
          ) {
            highlightNodeGraph("bfs-svg", n.id, "visited");
          }
          if (bfsState.queue.includes(n.id))
            highlightNodeGraph("bfs-svg", n.id, "queue");
        });
        highlightNodeGraph("bfs-svg", curr, "active");
      }

      // DFS LOGIC
      function initDFS() {
        dfsState = {
          stack: ["A"],
          visited: new Set(["A"]),
          visitedOrder: [],
          current: null,
          finished: false,
        };
        drawGraph("dfs-svg", nodesData);
        document.getElementById("dfs-log").innerText = "Ready. Start at A.";
        document.getElementById("dfs-stack-display").innerText = "[A]";
        document.getElementById("dfs-visited-display").innerText = "[]";
        highlightNodeGraph("dfs-svg", "A", "queue");
      }

      function stepDFS() {
        if (dfsState.finished) return;
        if (dfsState.stack.length === 0) {
          dfsState.finished = true;
          document.getElementById("dfs-log").innerText = "Stack empty. Done.";
          return;
        }
        const curr = dfsState.stack.pop();
        dfsState.current = curr;
        dfsState.visitedOrder.push(curr);
        document.getElementById(
          "dfs-visited-display"
        ).innerText = `[${dfsState.visitedOrder.join(", ")}]`;
        highlightNodeGraph("dfs-svg", curr, "active");
        document.getElementById(
          "dfs-log"
        ).innerText = `Popped ${curr}. Checking children...`;

        const nodeObj = nodesData.find((n) => n.id === curr);
        const children = [...nodeObj.children].reverse();
        let added = [];
        children.forEach((child) => {
          if (!dfsState.visited.has(child)) {
            dfsState.visited.add(child);
            dfsState.stack.push(child);
            added.push(child);
            highlightNodeGraph("dfs-svg", child, "queue");
          }
        });
        document.getElementById(
          "dfs-stack-display"
        ).innerText = `[${dfsState.stack.join(", ")}]`;
        if (added.length > 0)
          document.getElementById("dfs-log").innerText += ` Pushed ${added.join(
            ", "
          )}.`;
        else
          document.getElementById(
            "dfs-log"
          ).innerText += ` Dead end or all visited.`;

        nodesData.forEach((n) => {
          if (
            dfsState.visited.has(n.id) &&
            n.id !== curr &&
            !dfsState.stack.includes(n.id)
          ) {
            highlightNodeGraph("dfs-svg", n.id, "visited");
          }
          if (dfsState.stack.includes(n.id))
            highlightNodeGraph("dfs-svg", n.id, "queue");
        });
        highlightNodeGraph("dfs-svg", curr, "active");
      }

      // === TOPO SORT ===
      let topoNodes = [
        { id: "A", x: 50, y: 125, next: ["B", "C"] },
        { id: "B", x: 150, y: 50, next: ["D"] },
        { id: "C", x: 150, y: 200, next: ["D", "E"] },
        { id: "D", x: 250, y: 125, next: ["F"] },
        { id: "E", x: 250, y: 220, next: ["F"] },
        { id: "F", x: 350, y: 125, next: [] },
      ];

      function generateRandomDAG() {
        const nodeIds = ["A", "B", "C", "D", "E", "F", "G"];

        // Structured Layout Generation (Layer-based)
        // We define a fixed structure of layers to ensure no overlaps.
        // This mimics the clean BFS/DFS tree look but allows for DAG connections.

        // Randomize number of nodes (4 to 7)
        const minNodes = 4;
        const maxNodes = 7;
        const totalNodes =
          Math.floor(Math.random() * (maxNodes - minNodes + 1)) + minNodes;

        // Generate random layer structure
        let structure = [1]; // Always start with 1 node (Root)
        let remaining = totalNodes - 1;

        while (remaining > 0) {
          // Max 3 nodes per layer to keep it readable within width
          const maxInLayer = Math.min(remaining, 3);
          // Bias towards 2 nodes if possible for better shape
          let count = Math.floor(Math.random() * maxInLayer) + 1;

          // If we have exactly 2 remaining, often nice to just do 2
          if (remaining === 2 && Math.random() > 0.3) count = 2;

          structure.push(count);
          remaining -= count;
        }

        let currentIdIndex = 0;
        let nodes = [];
        let nodesByLayer = [];

        const width = 400;
        const height = 250;
        const layerHeight = height / (structure.length + 1);

        // 1. Create Nodes in Layers
        structure.forEach((count, layerIdx) => {
          let layerNodes = [];
          const layerY = 40 + layerIdx * 60;
          const layerWidth = width / (count + 1);

          for (let i = 0; i < count; i++) {
            if (currentIdIndex >= nodeIds.length) break;
            const id = nodeIds[currentIdIndex++];
            const x = (i + 1) * layerWidth;
            const node = { id, x, y: layerY, next: [], layer: layerIdx };
            nodes.push(node);
            layerNodes.push(node);
          }
          nodesByLayer.push(layerNodes);
        });

        // 2. Generate Edges (Strictly Adjacent Layers)
        // This prevents long lines crossing over nodes.
        for (let i = 0; i < nodesByLayer.length - 1; i++) {
          const currentLayer = nodesByLayer[i];
          const nextLayer = nodesByLayer[i + 1];

          // A. Ensure every node in Next Layer has at least one parent
          nextLayer.forEach((target) => {
            // Connect to the "closest" parent in X to minimize crossing
            // or just a random one. Let's try closest X.
            let bestParent = currentLayer[0];
            let minDist = Math.abs(target.x - bestParent.x);

            currentLayer.forEach((p) => {
              const d = Math.abs(target.x - p.x);
              if (d < minDist) {
                minDist = d;
                bestParent = p;
              }
            });

            if (!bestParent.next.includes(target.id)) {
              bestParent.next.push(target.id);
            }
          });

          // B. Ensure every node in Current Layer has at least one child
          currentLayer.forEach((source) => {
            if (source.next.length === 0) {
              // Connect to closest child
              let bestChild = nextLayer[0];
              let minDist = Math.abs(source.x - bestChild.x);

              nextLayer.forEach((c) => {
                const d = Math.abs(source.x - c.x);
                if (d < minDist) {
                  minDist = d;
                  bestChild = c;
                }
              });

              source.next.push(bestChild.id);
            }
          });

          // C. Add a few random extra edges between adjacent layers for complexity
          // But only if they don't cross too wildly (simple check: don't cross from far left to far right)
          if (Math.random() > 0.3) {
            const s =
              currentLayer[Math.floor(Math.random() * currentLayer.length)];
            const t = nextLayer[Math.floor(Math.random() * nextLayer.length)];
            // Allow if distance isn't huge
            if (Math.abs(s.x - t.x) < 150 && !s.next.includes(t.id)) {
              s.next.push(t.id);
            }
          }
        }

        topoNodes = nodes;
        initTopo();
      }

      let topoStack = [];
      let topoVisited = new Set();
      let topoActivePath = [];
      let topoState = "idle";
      let topoDfsStack = [];

      function drawTopo() {
        const svg = document.getElementById("topo-svg");
        let html = `<defs><marker id="arrow" markerWidth="10" markerHeight="10" refX="28" refY="3" orient="auto"><path d="M0,0 L0,6 L9,3 z" fill="#64748b" /></marker></defs>`;

        topoNodes.forEach((n) => {
          n.next.forEach((targetId) => {
            const t = topoNodes.find((x) => x.id === targetId);
            // Straight line with arrow
            html += `<line x1="${n.x}" y1="${n.y}" x2="${t.x}" y2="${t.y}" stroke="#475569" stroke-width="2" marker-end="url(#arrow)" />`;
          });
        });

        topoNodes.forEach((n) => {
          let colorClass = "fill-[#1e293b] stroke-[#94a3b8]";
          if (topoVisited.has(n.id))
            colorClass = "fill-emerald-600 stroke-white";
          if (topoActivePath.includes(n.id))
            colorClass = "fill-red-500 stroke-white";
          html += `<g><circle cx="${n.x}" cy="${n.y}" r="18" class="${colorClass}" stroke-width="2" /><text x="${n.x}" y="${n.y}" dy="5" text-anchor="middle" fill="white" font-weight="bold" font-size="12">${n.id}</text></g>`;
        });
        svg.innerHTML = html;
      }

      function initTopo() {
        topoStack = [];
        topoVisited = new Set();
        topoActivePath = [];
        topoState = "idle";
        topoDfsStack = ["A"];
        document.getElementById("topo-stack").innerHTML = "";
        document.getElementById("topo-log").innerText = "Ready. Start at A.";
        document.getElementById("topo-result-box").classList.add("hidden");
        drawTopo();
      }

      function topoNextStep() {
        if (topoState === "finished") return;
        if (topoDfsStack.length === 0) {
          const left = topoNodes.find((n) => !topoVisited.has(n.id));
          if (left) {
            topoDfsStack.push(left.id);
          } else {
            topoState = "finished";
            document.getElementById("topo-log").innerText = "DFS Complete.";
            const reversed = [...topoStack].reverse();
            document
              .getElementById("topo-result-box")
              .classList.remove("hidden");
            document.getElementById("topo-final-order").innerText =
              reversed.join(" -> ");
            return;
          }
        }
        const curr = topoDfsStack[topoDfsStack.length - 1];
        if (!curr) return;
        topoActivePath = [...topoDfsStack];
        const nodeObj = topoNodes.find((n) => n.id === curr);
        const hasWork = nodeObj.next.some(
          (childId) => !topoVisited.has(childId)
        );
        if (hasWork) {
          const nextC = nodeObj.next.find(
            (childId) => !topoVisited.has(childId)
          );
          if (nextC) {
            topoDfsStack.push(nextC);
            document.getElementById(
              "topo-log"
            ).innerText = `Visiting child ${nextC}...`;
          }
        } else {
          const doneNode = topoDfsStack.pop();
          topoVisited.add(doneNode);
          topoStack.push(doneNode);
          const stackHtml = topoStack
            .map(
              (n) =>
                `<span class="border border-emerald-500 px-2 rounded">${n}</span>`
            )
            .join(" ");
          document.getElementById("topo-stack").innerHTML = stackHtml;
          document.getElementById(
            "topo-log"
          ).innerText = `${doneNode} is dead end. Push to stack. Backtrack.`;
        }
        drawTopo();
      }

      // === PERMUTATION (JOHNSON-TROTTER) ===
      let jtState = {
        n: 4,
        p: [], // { val: 1, dir: -1 (left) or 1 (right) }
        permutationsFound: [],
        finished: false,
        stepDesc: "Ready",
        mobileIndex: -1,
        swappedIndices: [],
      };

      function initJT() {
        const nInput = document.getElementById("jtInput");
        let n = parseInt(nInput.value);
        if (isNaN(n) || n < 2) n = 4;
        if (n > 5) n = 5; // Cap at 5 for UI sanity
        nInput.value = n;

        jtState.n = n;
        jtState.p = [];
        for (let i = 1; i <= n; i++) {
          jtState.p.push({ val: i, dir: -1 }); // -1 = LEFT, 1 = RIGHT
        }
        jtState.permutationsFound = [getPermString()];
        jtState.finished = false;
        jtState.stepDesc = "Initial Permutation. All pointing LEFT.";
        jtState.mobileIndex = -1;
        jtState.swappedIndices = [];

        // Find initial mobile element for visualization
        jtState.mobileIndex = getMobileIndex();

        renderJT();
      }

      function runAllJT() {
        initJT();
        while (!jtState.finished) {
          stepJT(false); // false = don't render every step for speed
        }
        renderJT();
      }

      function getPermString() {
        return jtState.p.map((x) => x.val).join("");
      }

      function getMobileIndex() {
        let maxMobile = -1;
        let idx = -1;
        for (let i = 0; i < jtState.n; i++) {
          const item = jtState.p[i];
          // Check if mobile
          // Pointing left (-1) and i > 0 and val > neighbor
          if (item.dir === -1 && i > 0 && item.val > jtState.p[i - 1].val) {
            if (item.val > maxMobile) {
              maxMobile = item.val;
              idx = i;
            }
          }
          // Pointing right (1) and i < n-1 and val > neighbor
          if (
            item.dir === 1 &&
            i < jtState.n - 1 &&
            item.val > jtState.p[i + 1].val
          ) {
            if (item.val > maxMobile) {
              maxMobile = item.val;
              idx = i;
            }
          }
        }
        return idx;
      }

      function stepJT(render = true) {
        if (jtState.finished) return;

        const mIdx = getMobileIndex();
        if (mIdx === -1) {
          jtState.finished = true;
          jtState.stepDesc = "No mobile elements left. Algorithm Finished.";
          if (render) renderJT();
          return;
        }

        const mobileItem = jtState.p[mIdx];
        const swapIdx = mIdx + mobileItem.dir;

        // Swap
        const temp = jtState.p[swapIdx];
        jtState.p[swapIdx] = jtState.p[mIdx];
        jtState.p[mIdx] = temp;

        jtState.swappedIndices = [mIdx, swapIdx];

        // Reverse direction of all elements > mobileItem.val
        let reversed = [];
        for (let i = 0; i < jtState.n; i++) {
          if (jtState.p[i].val > mobileItem.val) {
            jtState.p[i].dir *= -1;
            reversed.push(jtState.p[i].val);
          }
        }

        jtState.permutationsFound.push(getPermString());

        let revText =
          reversed.length > 0
            ? ` Reversed directions of elements > ${
                mobileItem.val
              } (${reversed.join(",")}).`
            : "";
        jtState.stepDesc = `Largest mobile is ${mobileItem.val}. Swapped with ${temp.val}.${revText}`;

        // Prepare next mobile index for highlighting
        jtState.mobileIndex = getMobileIndex();
        if (jtState.mobileIndex === -1) {
          jtState.stepDesc += " Done.";
          jtState.finished = true;
        }

        if (render) renderJT();
      }

      function renderJT() {
        const container = document.getElementById("jt-visual");
        const status = document.getElementById("jt-status");
        const history = document.getElementById("jt-history");
        const count = document.getElementById("jt-count");

        status.innerText = jtState.stepDesc;
        count.innerText = jtState.permutationsFound.length;

        // Render Blocks
        let html = "";
        jtState.p.forEach((item, idx) => {
          const isMobile = idx === jtState.mobileIndex;
          const isSwapped = jtState.swappedIndices.includes(idx);

          let bgClass = "bg-slate-800 border-slate-600";
          if (isMobile)
            bgClass =
              "bg-blue-900 border-blue-500 shadow-[0_0_15px_rgba(59,130,246,0.5)]";
          else if (isSwapped) bgClass = "bg-emerald-900 border-emerald-500";

          const arrow = item.dir === -1 ? "←" : "→";

          html += `
                <div class="flex flex-col items-center transition-all duration-300">
                    <div class="text-slate-400 text-lg font-bold mb-1 ${
                      isMobile ? "text-blue-400 animate-bounce" : ""
                    }">${arrow}</div>
                    <div class="w-16 h-16 flex items-center justify-center rounded-lg border-2 text-2xl font-bold text-white ${bgClass}">
                        ${item.val}
                    </div>
                </div>
            `;
        });
        container.innerHTML = html;

        // Render History
        history.innerHTML = jtState.permutationsFound
          .map(
            (p, i) =>
              `<div class="flex items-center gap-2 w-full border-b border-slate-800 py-1">
                  <span class="text-slate-500 w-8 text-right">${i + 1}.</span>
                  <span class="text-emerald-400 font-bold tracking-widest">${p}</span>
               </div>`
          )
          .join("");

        // Scroll history to bottom
        history.scrollTop = history.scrollHeight;
      }

      // === HORNER'S RULE ===
      let hornerState = { coeffs: [], x: 0, step: 0, result: 0 };
      function updatePolynomial() {
        const cStr = document.getElementById("hornerCoeffs").value;
        const coeffs = cStr
          .trim()
          .split(/\s+/)
          .map(Number)
          .filter((n) => !isNaN(n));
        if (coeffs.length === 0) return;
        let html = "f(x) = ";
        const degree = coeffs.length - 1;
        coeffs.forEach((c, i) => {
          const power = degree - i;
          if (c === 0) return;
          if (i > 0 && c > 0) html += " + ";
          if (c < 0) html += " - ";
          const val = Math.abs(c);
          if (val !== 1 || power === 0) html += val;
          if (power > 0) html += "x";
          if (power > 1) html += `<sup>${power}</sup>`;
        });
        document.getElementById("poly-display").innerHTML = html;
      }

      function initHorner() {
        const cStr = document.getElementById("hornerCoeffs").value;
        const xVal = parseFloat(document.getElementById("hornerX").value);
        hornerState.coeffs = cStr.trim().split(/\s+/).map(Number);
        hornerState.x = xVal;
        hornerState.step = 0;
        hornerState.result = hornerState.coeffs[0];
        renderHornerTable();
        updatePolynomial();
        document.getElementById("horner-explanation").innerText =
          "Click Next Step to start.";
      }

      function randomizeHorner() {
        const numCoeffs = Math.floor(Math.random() * 4) + 3; // 3 to 6 coeffs
        const coeffs = Array.from(
          { length: numCoeffs },
          () => Math.floor(Math.random() * 20) - 10
        );
        const x = Math.floor(Math.random() * 10) - 5;

        document.getElementById("hornerCoeffs").value = coeffs.join(" ");
        document.getElementById("hornerX").value = x;
        initHorner();
      }

      function hornerStep() {
        if (hornerState.step >= hornerState.coeffs.length - 1) {
          document.getElementById("horner-explanation").innerText =
            "Finished. Final Answer: " + hornerState.result;
          return;
        }
        hornerState.step++;
        const prev = hornerState.result;
        const mult = prev * hornerState.x;
        const currCoeff = hornerState.coeffs[hornerState.step];
        hornerState.result = mult + currCoeff;
        renderHornerTable();
        document.getElementById(
          "horner-explanation"
        ).innerText = `Step ${hornerState.step}: ${prev} × ${hornerState.x} = ${mult}. Then ${mult} + ${currCoeff} = ${hornerState.result}`;
      }

      function renderHornerTable() {
        const container = document.getElementById("horner-container");
        const { coeffs, x, step, result } = hornerState;
        let row1 = `<div class="flex"><div class="w-24 text-slate-500 text-sm p-2">Coeffs:</div>`;
        let row2 = `<div class="flex"><div class="w-24 text-slate-500 text-sm p-2">Multiply:</div>`;
        let row3 = `<div class="flex"><div class="w-24 text-slate-500 text-sm p-2">Sum:</div>`;
        coeffs.forEach((c, i) => {
          row1 += `<div class="w-20 p-2 text-center border border-slate-700 ${
            i === step ? "highlight-coeff text-white" : "text-slate-300"
          }">${c}</div>`;
          if (i === 0) {
            row2 += `<div class="w-20 p-2 text-center border border-slate-800 text-slate-600">↓</div>`;
            row3 += `<div class="w-20 p-2 text-center border border-slate-700 font-bold bg-slate-800">${coeffs[0]}</div>`;
          } else if (i <= step) {
            let tempR = coeffs[0];
            for (let k = 1; k < i; k++) tempR = tempR * x + coeffs[k];
            let valMult = tempR * x;
            let valSum = valMult + c;
            row2 += `<div class="w-20 p-2 text-center border border-slate-800 text-slate-400 text-sm">${valMult}</div>`;
            row3 += `<div class="w-20 p-2 text-center border border-slate-700 font-bold text-white ${
              i === step ? "highlight-result" : "bg-slate-800"
            }">${valSum}</div>`;
          } else {
            row2 += `<div class="w-20 p-2 text-center border border-slate-800"></div>`;
            row3 += `<div class="w-20 p-2 text-center border border-slate-800"></div>`;
          }
        });
        row1 += `</div>`;
        row2 += `</div>`;
        row3 += `</div>`;
        container.innerHTML = row1 + row2 + row3;
      }

      // === RUSSIAN PEASANT ===
      function randomizeRussian() {
        const a = Math.floor(Math.random() * 50) + 10;
        const b = Math.floor(Math.random() * 50) + 10;
        document.getElementById("russianA").value = a;
        document.getElementById("russianB").value = b;
        calcRussian();
      }

      function calcRussian() {
        let a = parseInt(document.getElementById("russianA").value);
        let b = parseInt(document.getElementById("russianB").value);
        let sum = 0;
        let html = `
                <div class="grid grid-cols-4 gap-4 text-right mb-2 border-b border-slate-700 pb-2 font-bold text-slate-400 text-sm">
                    <div>Halve</div><div>Double</div><div>Check</div><div>Add to Sum</div>
                </div>`;
        while (a >= 1) {
          let keep = a % 2 !== 0;
          if (keep) sum += b;
          html += `
                    <div class="grid grid-cols-4 gap-4 text-right items-center p-2 rounded transition hover:bg-slate-800 ${
                      keep
                        ? "border-l-4 border-green-500 bg-green-900/20"
                        : "opacity-50 strike-through"
                    }">
                        <div>${a}</div><div>${b}</div>
                        <div class="text-xs">${keep ? "ODD" : "EVEN"}</div>
                        <div class="${
                          keep ? "text-green-400 font-bold" : ""
                        }">${keep ? "+ " + b : "-"}</div>
                    </div>`;
          a = Math.floor(a / 2);
          b = b * 2;
        }
        html += `
                <div class="grid grid-cols-4 gap-4 text-right mt-4 pt-4 border-t-2 border-slate-600">
                    <div></div><div></div><div class="font-bold text-white">TOTAL:</div>
                    <div class="font-bold text-green-400 text-xl">${sum}</div>
                </div>`;
        document.getElementById("russianOutput").innerHTML = html;
      }

      // === COUNTING SORT ===
      function randomizeCounting() {
        const len = Math.floor(Math.random() * 5) + 5; // 5 to 9 numbers
        const arr = Array.from({ length: len }, () =>
          Math.floor(Math.random() * 6)
        ); // 0 to 5
        document.getElementById("countInput").value = arr.join(", ");
        calcCounting();
      }

      function calcCounting() {
        const inputStr = document.getElementById("countInput").value;
        const arr = inputStr
          .split(",")
          .map((n) => parseInt(n.trim()))
          .filter((n) => !isNaN(n));
        if (arr.length === 0) return;
        const max = Math.max(...arr);
        const counts = new Array(max + 1).fill(0);
        arr.forEach((x) => counts[x]++);
        const cum = [...counts];
        for (let i = 1; i < cum.length; i++) cum[i] += cum[i - 1];
        const starts = [0, ...cum.slice(0, -1)];
        let html = `
                <div class="grid md:grid-cols-2 gap-8">
                    <div class="bg-slate-900 p-4 rounded border border-slate-700">
                        <h3 class="text-sm font-bold text-blue-400 mb-3 uppercase">1. Count Frequencies</h3>
                        <div class="grid grid-cols-2 gap-px bg-slate-700 border border-slate-700">
                            <div class="bg-slate-800 p-2 text-xs text-slate-400 font-bold">Value</div>
                            <div class="bg-slate-800 p-2 text-xs text-slate-400 font-bold">Count</div>
                            ${counts
                              .map(
                                (c, i) =>
                                  `<div class="bg-slate-900 p-2 text-sm text-center">${i}</div><div class="bg-slate-900 p-2 text-sm text-center text-blue-300 font-bold">${c}</div>`
                              )
                              .join("")}
                        </div>
                    </div>
                    <div class="bg-slate-900 p-4 rounded border border-slate-700">
                        <h3 class="text-sm font-bold text-purple-400 mb-3 uppercase">2. Starting Positions</h3>
                        <div class="grid grid-cols-2 gap-px bg-slate-700 border border-slate-700">
                            <div class="bg-slate-800 p-2 text-xs text-slate-400 font-bold">Value</div>
                            <div class="bg-slate-800 p-2 text-xs text-slate-400 font-bold">Start Index</div>
                            ${starts
                              .map(
                                (s, i) =>
                                  `<div class="bg-slate-900 p-2 text-sm text-center">${i}</div><div class="bg-slate-900 p-2 text-sm text-center text-purple-300 font-bold">${s}</div>`
                              )
                              .join("")}
                        </div>
                    </div>
                </div>
                <div class="bg-black p-4 rounded border-l-4 border-emerald-500">
                    <h3 class="text-sm font-bold text-emerald-400 mb-2 uppercase">3. Final Sorted Array</h3>
                    <div class="text-xl font-mono tracking-widest">[ ${arr
                      .sort((a, b) => a - b)
                      .join(", ")} ]</div>
                </div>
            `;
        document.getElementById("countingSteps").innerHTML = html;
      }

      // === HORSPOOL ===
      let hsState = { text: "", pattern: "", table: {}, shift: 0, index: 0 };
      function initHorspool() {
        const t = document.getElementById("horspoolText").value.toUpperCase();
        const p = document
          .getElementById("horspoolPattern")
          .value.toUpperCase();
        if (!t || !p) return;
        const len = p.length;
        const table = {};
        const unique = [...new Set(p.split(""))];
        unique.forEach((c) => (table[c] = len));
        for (let i = 0; i < len - 1; i++) table[p[i]] = len - 1 - i;
        hsState = { text: t, pattern: p, table, shift: 0, index: p.length - 1 };
        const tableHtml =
          Object.entries(table)
            .map(
              ([char, val]) =>
                `<div class="bg-slate-900 border border-slate-600 px-2 py-1 rounded text-center min-w-[30px]"><div class="text-xs text-slate-500">${char}</div><div class="font-bold text-white">${val}</div></div>`
            )
            .join("") +
          `<div class="bg-slate-900 border border-slate-600 px-2 py-1 rounded text-center min-w-[30px] opacity-70"><div class="text-xs text-slate-500">*</div><div class="font-bold text-white">${len}</div></div>`;
        document.getElementById("h-table-content").innerHTML = tableHtml;
        document.getElementById("horspool-log").innerText =
          "Ready. Pattern aligns at 0.";
        renderHorspoolVis();
      }
      function renderHorspoolVis() {
        const { text, pattern, shift } = hsState;
        let tHtml = `<div>`;
        for (let i = 0; i < text.length; i++)
          tHtml += `<span class="inline-block w-8 text-center border border-transparent text-slate-400" id="hp-t-${i}">${text[i]}</span>`;
        tHtml += `</div>`;
        let pHtml = `<div class="mt-1 transition-all duration-300" style="margin-left: ${
          shift * 32
        }px">`;
        for (let i = 0; i < pattern.length; i++)
          pHtml += `<span class="inline-block w-8 text-center border border-blue-500 bg-blue-900/30 text-white font-bold" id="hp-p-${i}">${pattern[i]}</span>`;
        pHtml += `</div>`;
        document.getElementById("horspool-vis-container").innerHTML =
          tHtml + pHtml;
      }
      function horspoolStep() {
        const { text, pattern, shift } = hsState;
        if (shift > text.length - pattern.length) {
          document.getElementById("horspool-log").innerText = "End of text.";
          return;
        }
        let m = pattern.length - 1;
        let matchLen = 0;
        document
          .querySelectorAll('[id^="hp-p-"]')
          .forEach((el) => el.classList.remove("bg-green-500", "bg-red-500"));
        while (m >= 0) {
          const textChar = text[shift + m];
          const pattChar = pattern[m];
          if (textChar === pattChar) {
            document.getElementById(`hp-p-${m}`).classList.add("bg-green-500");
            m--;
            matchLen++;
          } else {
            document.getElementById(`hp-p-${m}`).classList.add("bg-red-500");
            const lastTextChar = text[shift + pattern.length - 1];
            const jump = hsState.table[lastTextChar] || pattern.length;
            document.getElementById(
              "horspool-log"
            ).innerText = `Mismatch! Last text char '${lastTextChar}' says shift ${jump}.`;
            hsState.shift += jump;
            setTimeout(renderHorspoolVis, 1000);
            return;
          }
        }
        if (matchLen === pattern.length) {
          document.getElementById("horspool-log").innerText = "MATCH FOUND!";
          hsState.shift += 1;
        }
      }

      // === DIJKSTRA ===
      let dNodes = [
        { id: "A", x: 50, y: 150 },
        { id: "B", x: 150, y: 50 },
        { id: "C", x: 150, y: 250 },
        { id: "D", x: 250, y: 150 },
        { id: "E", x: 350, y: 150 },
      ];
      let dEdges = [
        { u: "A", v: "B", w: 4 },
        { u: "A", v: "C", w: 2 },
        { u: "B", v: "C", w: 1 },
        { u: "B", v: "D", w: 5 },
        { u: "C", v: "D", w: 8 },
        { u: "C", v: "E", w: 10 },
        { u: "D", v: "E", w: 2 },
      ];
      let adj = {};

      function buildAdj() {
        adj = {};
        dNodes.forEach((n) => (adj[n.id] = []));
        dEdges.forEach((e) => {
          adj[e.u].push({ to: e.v, w: e.w });
        });
      }
      buildAdj();

      function generateRandomWeightedGraph() {
        const nodeIds = ["A", "B", "C", "D", "E", "F"];
        const numNodes = Math.floor(Math.random() * 2) + 4; // 4 to 5 nodes
        const activeNodes = nodeIds.slice(0, numNodes);

        // Create nodes with structured positions (3 Lanes)
        // Keep A at start, others distributed
        const width = 400;
        const height = 250;
        const stepX = (width - 80) / (numNodes - 1);
        const lanes = [70, 125, 180]; // Top, Mid, Bot

        dNodes = activeNodes.map((id, idx) => {
          if (idx === 0) return { id, x: 40, y: 125 }; // A is Mid-Left
          if (idx === numNodes - 1) return { id, x: width - 40, y: 125 }; // Last is Mid-Right

          const x = 40 + idx * stepX;
          // Assign lane based on index to zigzag: Top, Bot, Top...
          const laneIdx = idx % 2 === 1 ? 0 : 2;
          const y = lanes[laneIdx];
          return { id, x, y };
        });

        // Create edges
        dEdges = [];
        // Ensure connectivity: each node (except last) connects to at least one future node
        for (let i = 0; i < dNodes.length - 1; i++) {
          const u = dNodes[i].id;
          // Connect to next node guaranteed
          const v = dNodes[i + 1].id;
          const w = Math.floor(Math.random() * 9) + 1;
          dEdges.push({ u, v, w });

          // Random extra connections (Skip 1 node max to keep it clean)
          if (i + 2 < dNodes.length && Math.random() > 0.5) {
            const v2 = dNodes[i + 2].id;
            const w2 = Math.floor(Math.random() * 9) + 1;
            dEdges.push({ u, v: v2, w: w2 });
          }
        }

        buildAdj();
        initDijkstra();
      }

      let dState = { table: {}, queue: [], curr: null, history: [] };

      function drawDijkstraGraph() {
        const svg = document.getElementById("dijkstra-svg");
        let html = `<defs><marker id="d-arrow" markerWidth="10" markerHeight="10" refX="28" refY="3" orient="auto"><path d="M0,0 L0,6 L9,3 z" fill="#64748b" /></marker></defs>`;

        dEdges.forEach((e) => {
          const u = dNodes.find((n) => n.id === e.u);
          const v = dNodes.find((n) => n.id === e.v);

          // Determine if we need a curve
          // If nodes are far apart (skip > 1 index) or same Y but not adjacent
          const dx = Math.abs(v.x - u.x);
          const dy = Math.abs(v.y - u.y);
          let pathD = "";
          let labelX = 0;
          let labelY = 0;

          if (dx > 100 || (Math.abs(u.y - v.y) < 10 && dx > 60)) {
            // Curve it
            // Direction depends on Y position.
            // If Top lane (y < 100), curve Up. If Bot lane (y > 150), curve Down.
            // If Mid, curve Up.
            const curveDir = u.y < 125 ? -1 : 1;
            const midX = (u.x + v.x) / 2;
            const midY = (u.y + v.y) / 2 + curveDir * 40; // Control point offset

            pathD = `M ${u.x} ${u.y} Q ${midX} ${midY} ${v.x} ${v.y}`;

            // Label position (approx at peak of curve)
            // Bezier mid point is at t=0.5: (1-t)^2*P0 + 2(1-t)t*P1 + t^2*P2
            // 0.25*P0 + 0.5*P1 + 0.25*P2
            labelX = 0.25 * u.x + 0.5 * midX + 0.25 * v.x;
            labelY = 0.25 * u.y + 0.5 * midY + 0.25 * v.y;
          } else {
            // Straight line
            pathD = `M ${u.x} ${u.y} L ${v.x} ${v.y}`;
            labelX = (u.x + v.x) / 2;
            labelY = (u.y + v.y) / 2;
          }

          html += `<path d="${pathD}" stroke="#475569" stroke-width="2" fill="none" marker-end="url(#d-arrow)" />`;

          // Weight Label with background
          html += `<rect x="${labelX - 10}" y="${
            labelY - 10
          }" width="20" height="20" fill="#0f172a" rx="4" /><text x="${labelX}" y="${labelY}" dy="5" text-anchor="middle" fill="#facc15" font-size="12" font-weight="bold">${
            e.w
          }</text>`;
        });

        dNodes.forEach((n) => {
          const info = dState.table[n.id];
          const isCurr = dState.curr === n.id;
          const isDone = info && info.visited;
          let fill = "#1e293b";
          let stroke = "#94a3b8";
          if (isDone) {
            fill = "#3b82f6";
            stroke = "white";
          }
          if (isCurr) {
            fill = "#ef4444";
            stroke = "white";
          }
          html += `<g><circle cx="${n.x}" cy="${n.y}" r="20" fill="${fill}" stroke="${stroke}" stroke-width="2" /><text x="${n.x}" y="${n.y}" dy="5" text-anchor="middle" fill="white" font-weight="bold">${n.id}</text></g>`;
        });
        svg.innerHTML = html;
      }

      function initDijkstra() {
        dState.table = {};
        dState.curr = null;
        dState.step = 0;
        dNodes.forEach((n) => {
          dState.table[n.id] = { cost: Infinity, parent: "-", visited: false };
        });
        dState.table["A"].cost = 0;

        // Clear and Setup Table Header
        const thead = document.querySelector("#dijkstra-table thead tr");
        thead.innerHTML =
          '<th class="p-2 border-r bg-slate-300 w-16 sticky left-0 z-10">Step</th>';
        dNodes.forEach((n) => {
          thead.innerHTML += `<th class="p-2 border-r min-w-[80px]">${n.id}</th>`;
        });

        document.getElementById("dijkstra-table-body").innerHTML = "";

        drawDijkstraGraph();
        logDijkstraRow("Init");
        document.getElementById("dijkstra-log").innerText =
          "Start at A (Cost 0).";
      }

      function logDijkstraRow(label) {
        const tbody = document.getElementById("dijkstra-table-body");
        const tr = document.createElement("tr");
        tr.className = "border-b border-slate-200 hover:bg-slate-50";

        let labelHtml = `<td class="p-2 border-r font-bold bg-slate-100 sticky left-0 z-10">${label}</td>`;
        tr.innerHTML += labelHtml;

        dNodes.forEach((n) => {
          const data = dState.table[n.id];
          let val = data.cost === Infinity ? "∞" : data.cost;
          let par = data.parent === "-" ? "" : `(${data.parent})`;
          let cellClass = "";
          let content = `${val} ${par}`;

          if (label === n.id)
            cellClass =
              "bg-red-100 text-red-700 font-bold border-2 border-red-500";

          // Logic: If already visited in a PREVIOUS step, don't show value (make empty).
          // "label" is the node currently being visited.
          // If data.visited is true, and n.id is NOT label, then it was visited before.
          // Exception: 'Init' row shows everything.
          if (label !== "Init" && data.visited && label !== n.id) {
            content = "";
            cellClass = "bg-slate-50";
          }

          tr.innerHTML += `<td class="p-2 border-r ${cellClass}">${content}</td>`;
        });

        tbody.appendChild(tr);
        // Scroll to bottom
        const container =
          document.querySelector("#dijkstra-table").parentElement;
        if (container) container.scrollTop = container.scrollHeight;
      }

      function dijkstraNext() {
        let minNode = null;
        let minVal = Infinity;
        dNodes.forEach((n) => {
          const t = dState.table[n.id];
          if (!t.visited && t.cost < minVal) {
            minVal = t.cost;
            minNode = n.id;
          }
        });

        if (!minNode) {
          document.getElementById("dijkstra-log").innerText = "Done.";
          dState.curr = null;
          drawDijkstraGraph();
          return;
        }

        dState.curr = minNode;
        dState.table[minNode].visited = true;

        const neighbors = adj[minNode];
        let logMsg = `Visited ${minNode}. `;
        neighbors.forEach((edge) => {
          const neighborId = edge.to;
          const newDist = dState.table[minNode].cost + edge.w;
          if (newDist < dState.table[neighborId].cost) {
            dState.table[neighborId].cost = newDist;
            dState.table[neighborId].parent = minNode;
          }
        });

        drawDijkstraGraph();
        logDijkstraRow(minNode);
      }

      // === FLOYD-WARSHALL ===
      let fNodes = [];
      let fEdges = [];
      let fState = {
        n: 0,
        dist: [],
        k: 0,
        i: 0,
        j: 0,
        finished: false,
        running: false,
      };

      function generateRandomFloyd() {
        const nodeIds = ["A", "B", "C", "D"];
        // Default 4 nodes.
        const numNodes = 4;
        const activeNodes = nodeIds.slice(0, numNodes);

        // Layout in a circle or square
        const width = 400;
        const height = 300;
        const cx = width / 2;
        const cy = height / 2;
        const r = 100;

        fNodes = activeNodes.map((id, idx) => {
          const angle = (idx / numNodes) * 2 * Math.PI - Math.PI / 2;
          return {
            id,
            x: cx + r * Math.cos(angle),
            y: cy + r * Math.sin(angle),
          };
        });

        // Generate edges
        // Default roughly 6 edges for 4 nodes. Max 7.
        const maxEdges = 7;
        const minEdges = 4;
        const numEdges =
          Math.floor(Math.random() * (maxEdges - minEdges + 1)) + minEdges;

        fEdges = [];
        let attempts = 0;
        while (fEdges.length < numEdges && attempts < 100) {
          attempts++;
          const u = fNodes[Math.floor(Math.random() * fNodes.length)];
          const v = fNodes[Math.floor(Math.random() * fNodes.length)];
          if (u.id === v.id) continue;
          if (fEdges.find((e) => e.u === u.id && e.v === v.id)) continue;

          fEdges.push({
            u: u.id,
            v: v.id,
            w: Math.floor(Math.random() * 9) + 1, // 1-9 weight
          });
        }

        initFloyd();
      }

      function drawFloydGraph() {
        const svg = document.getElementById("floyd-svg");
        let html = `<defs><marker id="f-arrow" markerWidth="10" markerHeight="10" refX="28" refY="3" orient="auto"><path d="M0,0 L0,6 L9,3 z" fill="#64748b" /></marker></defs>`;

        fEdges.forEach((e) => {
          const u = fNodes.find((n) => n.id === e.u);
          const v = fNodes.find((n) => n.id === e.v);

          // Curve if bidirectional edge exists or just for style
          const isBi = fEdges.find((ed) => ed.u === e.v && ed.v === e.u);

          let pathD = "";
          let labelX = 0;
          let labelY = 0;

          // Always curve slightly to avoid overlap and look nice
          // Calculate normal vector
          const dx = v.x - u.x;
          const dy = v.y - u.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const nx = -dy / dist;
          const ny = dx / dist;

          const curveAmt = 30;
          const midX = (u.x + v.x) / 2 + nx * curveAmt;
          const midY = (u.y + v.y) / 2 + ny * curveAmt;

          pathD = `M ${u.x} ${u.y} Q ${midX} ${midY} ${v.x} ${v.y}`;

          // Label at peak
          labelX = 0.25 * u.x + 0.5 * midX + 0.25 * v.x;
          labelY = 0.25 * u.y + 0.5 * midY + 0.25 * v.y;

          let stroke = "#475569";
          let width = "2";

          html += `<path d="${pathD}" stroke="${stroke}" stroke-width="${width}" fill="none" marker-end="url(#f-arrow)" />`;

          html += `<rect x="${labelX - 8}" y="${
            labelY - 8
          }" width="16" height="16" fill="#0f172a" rx="4" />
                   <text x="${labelX}" y="${labelY}" dy="4" text-anchor="middle" fill="#facc15" font-size="10" font-weight="bold">${
            e.w
          }</text>`;
        });

        fNodes.forEach((n) => {
          let fill = "#1e293b";
          let stroke = "#94a3b8";

          // Highlight k, i, j
          if (fState.running && !fState.finished) {
            const kNode = fNodes[fState.k];
            const iNode = fNodes[fState.i];
            const jNode = fNodes[fState.j];

            if (n.id === kNode.id) {
              fill = "#eab308";
              stroke = "white";
            } // K is Yellow
            else if (n.id === iNode.id) {
              fill = "#ef4444";
              stroke = "white";
            } // I is Red
            else if (n.id === jNode.id) {
              fill = "#3b82f6";
              stroke = "white";
            } // J is Blue
          }

          html += `<g><circle cx="${n.x}" cy="${n.y}" r="18" fill="${fill}" stroke="${stroke}" stroke-width="2" />
                   <text x="${n.x}" y="${n.y}" dy="5" text-anchor="middle" fill="white" font-weight="bold">${n.id}</text></g>`;
        });
        svg.innerHTML = html;
      }

      function initFloyd() {
        if (fNodes.length === 0) generateRandomFloyd(); // Ensure init

        const n = fNodes.length;
        fState = {
          n: n,
          dist: Array(n)
            .fill(0)
            .map(() => Array(n).fill(Infinity)),
          k: 0,
          i: 0,
          j: 0,
          finished: false,
          running: false,
        };

        // Init distances
        for (let i = 0; i < n; i++) fState.dist[i][i] = 0;
        fEdges.forEach((e) => {
          const uIdx = fNodes.findIndex((node) => node.id === e.u);
          const vIdx = fNodes.findIndex((node) => node.id === e.v);
          fState.dist[uIdx][vIdx] = e.w;
        });

        drawFloydGraph();
        renderFloydMatrix();
        document.getElementById("floyd-log").innerText =
          "Initialized D matrix. Ready.";
        document.getElementById("floyd-step-info").innerText = "Start";
      }

      function renderFloydMatrix() {
        const container = document.getElementById("floyd-matrix");
        const n = fState.n;

        // Grid template cols
        container.style.gridTemplateColumns = `auto repeat(${n}, 1fr)`;

        let html = `<div class="p-1"></div>`; // Corner
        fNodes.forEach(
          (node) =>
            (html += `<div class="p-1 font-bold text-slate-500">${node.id}</div>`)
        );

        for (let r = 0; r < n; r++) {
          html += `<div class="p-1 font-bold text-slate-500 flex items-center justify-center">${fNodes[r].id}</div>`;
          for (let c = 0; c < n; c++) {
            const val = fState.dist[r][c];
            const valStr = val === Infinity ? "∞" : val;

            let bg = "bg-slate-800";
            let border = "border-slate-700";

            // Highlight logic
            if (fState.running && !fState.finished) {
              // We are checking D[i][j] vs D[i][k] + D[k][j]
              // Highlight i,j cell
              if (r === fState.i && c === fState.j) {
                bg = "bg-blue-900";
                border = "border-blue-500";
              }
              // Highlight i,k and k,j
              if (
                (r === fState.i && c === fState.k) ||
                (r === fState.k && c === fState.j)
              ) {
                bg = "bg-yellow-900/50";
                border = "border-yellow-500";
              }
            }

            html += `<div class="p-2 border ${border} ${bg} rounded flex items-center justify-center transition-colors duration-200">${valStr}</div>`;
          }
        }
        container.innerHTML = html;
      }

      function floydNext() {
        if (fState.finished) return;
        fState.running = true;

        const { n, k, i, j, dist } = fState;
        const kNode = fNodes[k].id;
        const iNode = fNodes[i].id;
        const jNode = fNodes[j].id;

        // Logic
        const distIK = dist[i][k];
        const distKJ = dist[k][j];
        const currentDist = dist[i][j];
        const newDist = distIK + distKJ;

        let log = `k=${kNode}, i=${iNode}, j=${jNode}. Check ${iNode}->${jNode}. `;
        log += `D[${iNode}][${jNode}] = ${
          currentDist === Infinity ? "∞" : currentDist
        }. `;
        log += `Via ${kNode}: ${distIK === Infinity ? "∞" : distIK} + ${
          distKJ === Infinity ? "∞" : distKJ
        } = ${newDist === Infinity ? "∞" : newDist}. `;

        if (newDist < currentDist) {
          dist[i][j] = newDist;
          log += `Update! New shortest path found via ${kNode}.`;
        } else {
          log += `No update.`;
        }

        document.getElementById("floyd-log").innerText = log;
        document.getElementById("floyd-step-info").innerText = `k=${kNode} (${
          k + 1
        }/${n})`;

        drawFloydGraph();
        renderFloydMatrix();

        // Increment
        fState.j++;
        if (fState.j >= n) {
          fState.j = 0;
          fState.i++;
          if (fState.i >= n) {
            fState.i = 0;
            fState.k++;
            if (fState.k >= n) {
              fState.finished = true;
              fState.running = false;
              document.getElementById("floyd-log").innerText =
                "Finished! All pairs shortest paths computed.";
              document.getElementById("floyd-step-info").innerText = "Done";
              drawFloydGraph(); // Clear highlights
              renderFloydMatrix(); // Clear highlights
            }
          }
        }
      }

      function runAllFloyd() {
        if (fState.finished) return;
        while (!fState.finished) {
          floydNext();
        }
      }

      // === KNAPSACK (DP) ===
      let ksState = {
        capacity: 5,
        items: [], // {w, v, id}
        dp: [],
        i: 0, // current item index (1-based for DP logic)
        w: 0, // current weight index
        phase: "fill", // 'fill' or 'backtrack'
        finished: false,
        selected: [],
        backtrackI: 0,
        backtrackW: 0,
      };

      function generateRandomKnapsack() {
        const numItems = 4;
        const items = [];
        for (let i = 0; i < numItems; i++) {
          items.push({
            id: i + 1,
            w: Math.floor(Math.random() * 3) + 1, // 1-3 weight
            v: Math.floor(Math.random() * 10) + 5, // 5-15 value
          });
        }
        ksState.items = items;
        document.getElementById("ksCapacity").value = 5;
        initKnapsack();
      }

      function initKnapsack() {
        if (ksState.items.length === 0) generateRandomKnapsack();

        const cap = parseInt(document.getElementById("ksCapacity").value) || 5;
        const n = ksState.items.length;

        // Initialize DP table (n+1 rows, cap+1 cols)
        // Fill with -1 to show "uncalculated"
        const dp = Array(n + 1)
          .fill(0)
          .map(() => Array(cap + 1).fill(null));

        // Base case: row 0 and col 0 are 0
        for (let i = 0; i <= n; i++) dp[i][0] = 0;
        for (let w = 0; w <= cap; w++) dp[0][w] = 0;

        ksState = {
          capacity: cap,
          items: ksState.items,
          dp: dp,
          i: 1, // Start at first item
          w: 1, // Start at weight 1
          phase: "fill",
          finished: false,
          selected: [],
          backtrackI: n,
          backtrackW: cap,
        };

        document.getElementById("ks-result").classList.add("hidden");
        renderKnapsack();
        document.getElementById("ks-log").innerText =
          "Table initialized. Row 0 and Col 0 set to 0.";
      }

      function renderKnapsack() {
        // Render Items List
        const itemsDiv = document.getElementById("ks-items-display");
        itemsDiv.innerHTML = ksState.items
          .map((item, idx) => {
            const isCurrent = ksState.phase === "fill" && idx + 1 === ksState.i;
            const isSelected = ksState.selected.includes(item.id);
            let border = "border-slate-600";
            let bg = "bg-slate-900";

            if (isCurrent) {
              border = "border-blue-500";
              bg = "bg-blue-900/30";
            }
            if (isSelected) {
              border = "border-emerald-500";
              bg = "bg-emerald-900/50";
            }

            return `
                <div class="flex flex-col items-center p-2 border ${border} ${bg} rounded min-w-[60px]">
                    <div class="text-xs text-slate-400">Item ${item.id}</div>
                    <div class="font-bold text-white">W:${item.w}</div>
                    <div class="font-bold text-yellow-400">V:${item.v}</div>
                </div>
              `;
          })
          .join("");

        // Render Table
        const tableDiv = document.getElementById("ks-table");
        const cols = ksState.capacity + 1;
        tableDiv.style.gridTemplateColumns = `auto repeat(${cols}, 1fr)`;

        let html = `<div class="p-2 text-slate-500 text-xs">Item \\ Cap</div>`;
        for (let c = 0; c <= ksState.capacity; c++)
          html += `<div class="p-2 text-slate-500 font-bold text-xs bg-slate-800">${c}</div>`;

        for (let r = 0; r <= ksState.items.length; r++) {
          const label =
            r === 0
              ? "0"
              : `Item ${r} (w:${ksState.items[r - 1].w}, v:${
                  ksState.items[r - 1].v
                })`;
          html += `<div class="p-2 text-slate-400 text-xs bg-slate-800 flex items-center">${label}</div>`;

          for (let c = 0; c <= ksState.capacity; c++) {
            const val = ksState.dp[r][c];
            const valStr = val === null ? "" : val;

            let bg = "bg-slate-900";
            let border = "border-slate-700";

            // Highlight current cell being calculated
            if (
              ksState.phase === "fill" &&
              r === ksState.i &&
              c === ksState.w
            ) {
              bg = "bg-blue-600";
              border = "border-white";
            }
            // Highlight backtrack path
            if (
              ksState.phase === "backtrack" &&
              r === ksState.backtrackI &&
              c === ksState.backtrackW
            ) {
              bg = "bg-emerald-600";
              border = "border-white";
            }
            // Highlight cells involved in calculation (prev row)
            if (
              ksState.phase === "fill" &&
              r === ksState.i &&
              c === ksState.w
            ) {
              // Just visual aid, maybe too complex to highlight parents here without clutter
            }

            html += `<div class="h-8 flex items-center justify-center border ${border} ${bg} text-sm">${valStr}</div>`;
          }
        }
        tableDiv.innerHTML = html;

        // Render Result
        if (ksState.finished) {
          const resDiv = document.getElementById("ks-result");
          const selDiv = document.getElementById("ks-selected-items");
          resDiv.classList.remove("hidden");
          selDiv.innerHTML =
            ksState.selected.length > 0
              ? ksState.selected
                  .map((id) => {
                    const item = ksState.items.find((x) => x.id === id);
                    return `<div class="bg-emerald-600 text-white px-3 py-1 rounded font-bold">Item ${id} (V:${item.v})</div>`;
                  })
                  .join("")
              : '<div class="text-slate-400">No items selected</div>';
        }
      }

      function knapsackStep() {
        if (ksState.finished) return;

        if (ksState.phase === "fill") {
          const { i, w, items, dp } = ksState;
          const item = items[i - 1]; // 0-based index for items array

          let val = 0;
          let log = "";

          if (item.w > w) {
            val = dp[i - 1][w];
            log = `Item ${i} weight (${item.w}) > capacity ${w}. Copy from above: ${val}.`;
          } else {
            const valSkip = dp[i - 1][w];
            const valTake = item.v + dp[i - 1][w - item.w];
            val = Math.max(valSkip, valTake);
            log = `Item ${i} (w:${item.w}, v:${
              item.v
            }). Skip: ${valSkip}. Take: ${item.v} + dp[${i - 1}][${
              w - item.w
            }](${dp[i - 1][w - item.w]}) = ${valTake}. Max is ${val}.`;
          }

          dp[i][w] = val;
          document.getElementById("ks-log").innerText = log;

          // Advance
          ksState.w++;
          if (ksState.w > ksState.capacity) {
            ksState.w = 1;
            ksState.i++;
            if (ksState.i > ksState.items.length) {
              ksState.phase = "backtrack";
              document.getElementById("ks-log").innerText =
                "Table filled. Starting backtrack to find items.";
            }
          }
        } else if (ksState.phase === "backtrack") {
          let { backtrackI, backtrackW, dp, items } = ksState;

          if (backtrackI === 0 || backtrackW === 0) {
            ksState.finished = true;
            document.getElementById("ks-log").innerText = "Backtrack complete.";
            renderKnapsack();
            return;
          }

          const currentVal = dp[backtrackI][backtrackW];
          const prevVal = dp[backtrackI - 1][backtrackW];

          if (currentVal === prevVal) {
            document.getElementById(
              "ks-log"
            ).innerText = `Value ${currentVal} equals value above. Item ${backtrackI} NOT selected. Move up.`;
            ksState.backtrackI--;
          } else {
            const item = items[backtrackI - 1];
            document.getElementById(
              "ks-log"
            ).innerText = `Value ${currentVal} != value above. Item ${backtrackI} SELECTED. Move to dp[${
              backtrackI - 1
            }][${backtrackW - item.w}].`;
            ksState.selected.push(item.id);
            ksState.backtrackI--;
            ksState.backtrackW -= item.w;
          }
        }

        renderKnapsack();
      }

      function runAllKnapsack() {
        while (!ksState.finished) {
          knapsackStep();
        }
      }

      // Global Init
      window.onload = function () {
        initBFS();
        initDFS();
        initTopo();
        initJT();
        updatePolynomial();
        initHorner();
        calcRussian();
        calcCounting();
        initHorspool();
        initDijkstra();
        initFloyd();
        initKnapsack();
      };
    </script>
  </body>
</html>
